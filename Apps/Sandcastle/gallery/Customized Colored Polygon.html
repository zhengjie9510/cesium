<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <meta name="description" content="Polygon拉伸并添加动态纹理" />
    <meta name="cesium-sandcastle-labels" content="Customized" />
    <title>Cesium Demo</title>
    <script type="text/javascript" src="../Sandcastle-header.js"></script>
    <script
      type="text/javascript"
      src="../../../Build/CesiumUnminified/Cesium.js"
      nomodule
    ></script>
    <script type="module" src="../load-cesium-es6.js"></script>
  </head>

  <body
    class="sandcastle-loading"
    data-sandcastle-bucket="bucket-requirejs.html"
  >
    <style>
      @import url(../templates/bucket.css);
    </style>
    <div id="cesiumContainer" class="fullSize"></div>
    <div id="loadingOverlay">
      <h1>Loading...</h1>
    </div>
    <div id="toolbar"></div>
    <script id="cesium_sandcastle_script">
      function startup(Cesium) {
        "use strict";
        //Sandcastle_Begin
        // Create the viewer.
        var viewer = new Cesium.Viewer("cesiumContainer");
        if (Cesium.FeatureDetection.supportsImageRenderingPixelated()) {
          //判断是否支持图像渲染像素化处理
          viewer.resolutionScale = window.devicePixelRatio;
        }
        viewer.scene.postProcessStages.fxaa.enabled = true;
        var scene = viewer.scene;

        // Create the polygon geometry. The positions here are
        // in counter clockwise order.
        var positions = Cesium.Cartesian3.fromDegreesArray([
          116.39,
          39.9,
          116.395,
          39.9,
          116.395,
          39.895,
          116.39,
          39.895,
        ]);
        // Create a PolygonGeometry.
        var polygon = Cesium.PolygonGeometry.fromPositions({
          positions: positions,
          extrudedHeight: 1000,
          vertexFormat: Cesium.VertexFormat.POSITION_NORMAL_AND_ST,
        });
        // 创建一个 Geometry
        var geometry = Cesium.PolygonGeometry.createGeometry(polygon);

        // 目的：将Polygon立方体底部的纹理坐标设置为0，顶部的设置为1。
        // 方法一：获取Polygon立方体在笛卡尔积中的位置，并转为WGS84坐标系，获取高程，之后归一化
        // 方法二：完成方法一之后发现另一种更简单的办法：直接修改 PolygonGeometry.js 中 computeAttributes 函数
        var position = geometry.attributes.position.values;
        var height = [];
        for (
          var i = 0;
          i < geometry.attributes.position.values.length;
          i = i + 3
        ) {
          var point = new Cesium.Cartesian3(
            position[i],
            position[i + 1],
            position[i + 2]
          );
          var cartographicPosition = Cesium.Ellipsoid.WGS84.cartesianToCartographic(
            point
          );
          height.push(cartographicPosition.height);
        }
        var max = Math.max.apply(null, height);
        var min = Math.min.apply(null, height);
        var data = [];
        for (var i = 0; i < height.length; i++) {
          data.push(1);
          data.push((height[i] - min) / (max - min));
        }
        geometry.attributes.st.values = new Float32Array(data);

        var primitive = scene.primitives.add(
          new Cesium.Primitive({
            asynchronous: false,
            geometryInstances: new Cesium.GeometryInstance({
              geometry: geometry,
            }),
            appearance: new Cesium.MaterialAppearance({
              material: new Cesium.Material({
                translucent: false,
                fabric: {
                  uniforms: {
                    color: Cesium.Color.GAINSBORO,
                    offset1: 0.02,
                    offset2: 0.02,
                  },
                  source: `
                  uniform float offset2;
                  uniform float offset1;
                  uniform vec4 color;
                  czm_material czm_getMaterial(czm_materialInput materialInput)
                  {
                  czm_material material = czm_getDefaultMaterial(materialInput);
                  material.diffuse = czm_gammaCorrect(color.rgb); 
                  vec2 st = materialInput.st;
                  if(st.t> offset1-offset2 && st.t< offset1+offset2)
                  {
                    material.emission=vec3(0.7);
                  }
                  material.alpha = 1.0; 
                  return material;
                }`,
                },
              }),
            }),
          })
        );

        // 动态修改材质中的offset变量，从而实现动态效果。
        viewer.scene.preUpdate.addEventListener(function () {
          var offset = primitive.appearance.material.uniforms.offset1;
          offset += 0.01;
          if (offset > 0.98) {
            offset = 0.02;
          }
          primitive.appearance.material.uniforms.offset1 = offset;
        });

        viewer.camera.flyToBoundingSphere(geometry.boundingSphere);
        //Sandcastle_End
        Sandcastle.finishedLoading();
      }
      if (typeof Cesium !== "undefined") {
        window.startupCalled = true;
        startup(Cesium);
      }
    </script>
  </body>
</html>
